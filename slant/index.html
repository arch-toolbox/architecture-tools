<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>斜線オーバーレイ WEB版 v8_full_frontfix（縮尺一致＋前後レイヤー固定）</title>
<style>
  :root { --card: #ffffff; --ink:#111827; --muted:#6b7280; --line:#e5e7eb;}
  *{box-sizing:border-box}
  body{margin:0;background:#f3f4f6;color:var(--ink);font-family:ui-sans-serif,system-ui,Roboto,"Noto Sans JP",sans-serif}
  .wrap{max-width:1200px;margin:16px auto;padding:0 12px;display:grid;grid-template-columns:380px 1fr;gap:12px}
  .card{background:var(--card);border-radius:14px;box-shadow:0 8px 24px rgba(0,0,0,.06);padding:14px}
  .section-title{font-size:18px;font-weight:700;margin:0 0 8px}
  .row{display:flex;gap:8px;align-items:center;justify-content:space-between;margin:6px 0}
  .row label{font-size:13px}
  .row input[type="number"]{width:120px;padding:6px 8px;border:1px solid #d1d5db;border-radius:8px}
  .row select{width:180px;padding:6px 8px;border:1px solid #d1d5db;border-radius:8px}
  .hint{font-size:12px;color:var(--muted)}
  .btn{display:inline-flex;align-items:center;gap:6px;padding:8px 12px;border-radius:10px;border:1px solid #d1d5db;background:#f9fafb;cursor:pointer}
  .btn:hover{background:#f3f4f6}
  .color-dot{width:10px;height:10px;border-radius:999px;display:inline-block;margin-right:6px}
  .canvas-holder{position:relative;width:1000px;height:720px;background:#f3f4f6;border-radius:14px;overflow:hidden;border:1px dashed #d1d5db;margin:0 auto}
  .bgimg{position:absolute;inset:0;width:100%;height:100%;object-fit:contain;pointer-events:none;z-index:1;}
  #overlay{position:absolute;inset:0;z-index:2;pointer-events:none;}
  .origin{position:absolute;transform:translate(-50%,-50%);width:14px;height:14px;border-radius:999px;background:#4f46e5;box-shadow:0 0 0 2px #fff;z-index:3;}
  .origin-label{position:absolute;transform:translate(-50%,6px);font-size:10px;background:rgba(255,255,255,.9);padding:2px 4px;border-radius:6px;z-index:3;}
  .grid line{stroke:#e5e7eb;stroke-width:1}
  .axis line{stroke:#111827;stroke-dasharray:4 4}
  .two-col{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  .hr{border-top:1px solid #e5e7eb;margin:8px 0}
  .kbd{font-family:ui-monospace, Menlo, Consolas, monospace; background:#eef2ff; border:1px solid #c7d2fe; border-radius:6px; padding:0 6px;}
  .footer{font-size:12px;color:var(--muted);display:flex;justify-content:space-between;margin-top:6px;gap:8px;flex-wrap:wrap}
</style>
</head>
<body>
  <div class="wrap">
    <!-- left controls -->
    <div class="card">
      <h2 class="section-title">① 斜線種類と設定</h2>
      <div id="slant-panels"></div>

      <div class="hr"></div>

      <h2 class="section-title">② 画像と縮尺</h2>
      <div class="row">
        <label>画像読み込み（PNG/JPG）</label>
        <input id="imgInput" type="file" accept="image/*" />
      </div>
      <div class="row">
        <label>画像の不透明度</label>
        <input id="opacity" type="range" min="0.1" max="1" step="0.05" value="0.85" />
      </div>
      <div class="row">
        <label>縮尺 PPM [px/m]</label>
        <input id="ppm" type="number" step="1" value="100" />
      </div>
      <div class="row" style="justify-content:flex-start; gap:8px">
        <button id="calib" class="btn">縮尺キャリブレーション</button>
        <span class="hint">ステージ上で既知距離の2点をクリック→実距離[m]入力</span>
      </div>
      <div class="hint">原点（青丸）を境界にドラッグ。<br><b>CSSピクセル=SVG座標</b> なので、PPMキャリブそのままの寸法で一致します。</div>

      <div class="hr"></div>
      <div class="two-col">
        <button id="reset" class="btn">リセット</button>
        <button id="savePng" class="btn">PNG保存</button>
      </div>
    </div>

    <!-- right canvas -->
    <div class="card">
      <div id="stage" class="canvas-holder">
        <img id="bg" class="bgimg" alt="">
        <svg id="overlay" width="1000" height="720" viewBox="0 0 1000 720" preserveAspectRatio="none">
          <g class="grid" id="grid"></g>
          <g class="axis" id="axes"></g>
          <g id="slines"></g>
        </svg>

        <div id="origin" class="origin" title="ドラッグで基準点を移動"></div>
        <div id="originLabel" class="origin-label">(0m,0m)</div>
      </div>
      <div class="footer">
        <div>振れ角 φ は <b>断面Xと境界直交のズレ</b>。<span class="kbd">m' = m / cos φ</span>（45°→×√2）／反転＝左右ミラー。</div>
        <div id="status">PPM=100 px/m, 原点=(150, 600)</div>
      </div>
    </div>
  </div>

<script>
(function () {
  // ★ここを自分の Worker の URL に書き換える
  const SLANT_WORKER_URL = "https://weathered-pine-7fbe.1989yo55.workers.dev/";

  // ----- elements -----
  const stage = document.getElementById('stage');
  const bg = document.getElementById('bg');
  const overlay = document.getElementById('overlay');
  const grid = document.getElementById('grid');
  const axes = document.getElementById('axes');
  const slines = document.getElementById('slines');
  const originEl = document.getElementById('origin');
  const originLabel = document.getElementById('originLabel');
  const statusEl = document.getElementById('status');
  const imgInput = document.getElementById('imgInput');
  const opacityInput = document.getElementById('opacity');
  const ppmInput = document.getElementById('ppm');
  const resetBtn = document.getElementById('reset');
  const saveBtn = document.getElementById('savePng');
  const calibBtn = document.getElementById('calib');
  const panelsRoot = document.getElementById('slant-panels');

  // ----- state -----
  let currentBlobURL = null; // 画像URL解放用

  const state = {
    canvas: { w: 1000, h: 720 },
    ppm: 100,
    origin: { x: 150, y: 600 },
    opacity: 0.85,
    calibMode: false,
    calibPts: [],
    slants: [
      { id:"road",   label:"道路斜線", type:"road",   enabled:true,  mode:"slope", h0:1.2, m:1.25, theta:degFromSlope(1.25), d0:0, phi:0,   flip:false, color:"#2563eb" },
      { id:"north",  label:"北側斜線", type:"north",  enabled:true,  mode:"slope", h0:5.0, m:1.25, theta:degFromSlope(1.25), d0:0, phi:0,   flip:false, color:"#16a34a" },
      { id:"custom", label:"高度/カスタム斜線", type:"custom", enabled:false, mode:"angle", h0:0, m:slopeFromDeg(40), theta:40, d0:0, phi:0, flip:false, color:"#dc2626" },
    ],
  };

  // ----- helpers（UI側だけで使う軽めの計算） -----
  function slopeFromDeg(deg){ return Math.tan(deg*Math.PI/180); }
  function degFromSlope(m){ return Math.atan(m)*180/Math.PI; }
  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

  // ----- control panels -----
  function renderPanels(){
    panelsRoot.innerHTML = "";
    state.slants.forEach((s)=>{
      const div = document.createElement('div');
      div.className = "card";
      div.style.padding = "12px";
      div.style.marginBottom = "8px";
      div.innerHTML = `
        <div class="row" style="justify-content:space-between">
          <label class="font-medium">
            <span class="color-dot" style="background:${s.color}"></span>${s.label}
          </label>
          <label class="row" style="gap:8px">
            <input data-id="${s.id}" data-k="enabled" type="checkbox" ${s.enabled?"checked":""}/> 有効
          </label>
        </div>
        <div class="row">
          <label>入力モード</label>
          <select data-id="${s.id}" data-k="mode">
            <option value="slope" ${s.mode==="slope"?"selected":""}>勾配 m</option>
            <option value="angle" ${s.mode==="angle"?"selected":""}>角度 θ</option>
          </select>
        </div>
        <div class="two-col">
          <div class="row"><label>起点高さ h0[m]</label><input data-id="${s.id}" data-k="h0" type="number" step="0.1" value="${s.h0}"></div>
          ${
            s.mode==="slope"
            ? `<div class="row"><label>勾配 m</label><input data-id="${s.id}" data-k="m" type="number" step="0.05" value="${s.m}"></div>`
            : `<div class="row"><label>角度 θ[°]</label><input data-id="${s.id}" data-k="theta" type="number" step="1" value="${s.theta}"></div>`
          }
          <div class="row"><label>水平オフセット d0[m]</label><input data-id="${s.id}" data-k="d0" type="number" step="0.1" value="${s.d0}"></div>
          <div class="row"><label>振れ角 φ[°]</label><input data-id="${s.id}" data-k="phi" type="number" step="1" value="${s.phi}"></div>
        </div>
        <div class="row" style="justify-content:flex-start">
          <label class="hint"><input data-id="${s.id}" data-k="flip" type="checkbox" ${s.flip?"checked":""}/> 斜線を左右反転（右上↔左上）</label>
        </div>
        <div class="hint">線の向きは水平基準。m' = m / cos φ。PPMはCSSピクセル基準なので、キャリブと完全一致。</div>
      `;
      panelsRoot.appendChild(div);
    });

    // wire inputs
    panelsRoot.querySelectorAll('input,select').forEach(el=>{
      el.addEventListener('change', e=>{
        const t = e.target;
        const id = t.getAttribute('data-id');
        const k = t.getAttribute('data-k');
        const s = state.slants.find(x=>x.id===id);
        if(!s) return;

        if(t.type==="checkbox"){
          s[k] = t.checked;
        }else if(t.tagName==="SELECT"){
          s[k] = t.value;
          if(k==="mode"){
            // モード切り替え時の m / θ の相互変換
            if(s.mode==="slope"){ 
              s.m     = slopeFromDeg(s.theta || degFromSlope(s.m)); 
            }else{ 
              s.theta = degFromSlope(s.m); 
            }
          }
        }else{
          const val = parseFloat(t.value);
          if(k==="m"){ s.m = val; }
          else if(k==="theta"){ s.theta = val; }
          else if(k==="h0"||k==="d0"||k==="phi"){ s[k]=val; }
        }
        renderPanels(); // 入力UIを再構築
        draw();
      }, false);
    });
  }

  // ----- grid / axes -----
  function drawGrid(){
    const ppm = state.ppm;
    grid.innerHTML = "";
    const vstep = ppm/2;
    const hnum = Math.ceil(state.canvas.w / vstep);
    for(let i=0;i<=hnum;i++){
      const x = i*vstep;
      const line = document.createElementNS("http://www.w3.org/2000/svg","line");
      line.setAttribute("x1", x); line.setAttribute("y1", 0);
      line.setAttribute("x2", x); line.setAttribute("y2", state.canvas.h);
      grid.appendChild(line);
    }
    const hstep = ppm/2;
    const vnum = Math.ceil(state.canvas.h / hstep);
    for(let i=0;i<=vnum;i++){
      const y = i*hstep;
      const line = document.createElementNS("http://www.w3.org/2000/svg","line");
      line.setAttribute("x1", 0); line.setAttribute("y1", y);
      line.setAttribute("x2", state.canvas.w); line.setAttribute("y2", y);
      grid.appendChild(line);
    }

    axes.innerHTML = "";
    const axX = document.createElementNS("http://www.w3.org/2000/svg","line");
    axX.setAttribute("x1", 0); axX.setAttribute("y1", state.origin.y);
    axX.setAttribute("x2", state.canvas.w); axX.setAttribute("y2", state.origin.y);
    axes.appendChild(axX);
    const axY = document.createElementNS("http://www.w3.org/2000/svg","line");
    axY.setAttribute("x1", state.origin.x); axY.setAttribute("y1", 0);
    axY.setAttribute("x2", state.origin.x); axY.setAttribute("y2", state.canvas.h);
    axes.appendChild(axY);
  }

  // ----- Worker 呼び出しで斜線ジオメトリを取得 -----
  let slantRequestId = 0;

  async function updateSlantsFromWorker(){
    const myId = ++slantRequestId;
    try{
      const payload = {
        canvas: state.canvas,
        ppm: state.ppm,
        origin: state.origin,
        slants: state.slants
      };
      const res = await fetch(SLANT_WORKER_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload)
      });
      if(!res.ok){
        console.error("斜線Workerエラー:", res.status);
        return;
      }
      const data = await res.json();
      if(myId !== slantRequestId) return; // 古いレスポンスは破棄

      slines.innerHTML = "";
      (data.slants || []).forEach(s => {
        // 斜線本体
        const line = document.createElementNS("http://www.w3.org/2000/svg","line");
        line.setAttribute("x1", s.x0);
        line.setAttribute("y1", s.y0);
        line.setAttribute("x2", s.x1);
        line.setAttribute("y2", s.y1);
        line.setAttribute("stroke", s.color);
        line.setAttribute("stroke-width", 2);
        slines.appendChild(line);

        // 角度弧
        if (s.arcPath) {
          const path = document.createElementNS("http://www.w3.org/2000/svg","path");
          path.setAttribute("d", s.arcPath);
          path.setAttribute("fill", "none");
          path.setAttribute("stroke", s.color);
          path.setAttribute("stroke-width", "1.5");
          slines.appendChild(path);
        }

        // 起点ドット
        if (s.dot) {
          const dot = document.createElementNS("http://www.w3.org/2000/svg","circle");
          dot.setAttribute("cx", s.dot.cx);
          dot.setAttribute("cy", s.dot.cy);
          dot.setAttribute("r", s.dot.r || 3);
          dot.setAttribute("fill", s.color);
          slines.appendChild(dot);
        }

        // ラベル
        if (s.label) {
          const txt = document.createElementNS("http://www.w3.org/2000/svg","text");
          txt.setAttribute("x", s.label.x);
          txt.setAttribute("y", s.label.y);
          txt.setAttribute("font-size","12");
          txt.setAttribute("fill", s.color);
          txt.textContent = s.label.text;
          slines.appendChild(txt);
        }
      });
    }catch(err){
      console.error("斜線Worker通信エラー:", err);
    }
  }

  // ----- 全体描画 -----
  function draw(){
    bg.style.opacity = state.opacity.toString();
    originEl.style.left = state.origin.x + "px";
    originEl.style.top = state.origin.y + "px";
    originLabel.style.left = state.origin.x + "px";
    originLabel.style.top = state.origin.y + "px";
    statusEl.textContent = `PPM=${state.ppm} px/m, 原点=(${state.origin.x.toFixed(0)}, ${state.origin.y.toFixed(0)})`;
    drawGrid();
    updateSlantsFromWorker(); // 斜線本体は Worker に計算させる
  }

  // ----- 画像読み込み -----
  imgInput.addEventListener('change', ()=>{
    const file = imgInput.files && imgInput.files[0];
    if(!file) return;

    const maxSize = 10 * 1024 * 1024;
    if(file.size > maxSize){
      alert(`ファイルサイズが大きすぎます。\n最大サイズ: 10MB\n選択されたファイル: ${(file.size/1024/1024).toFixed(2)}MB`);
      imgInput.value = '';
      return;
    }
    if(!['image/png', 'image/jpeg', 'image/jpg'].includes(file.type)){
      alert('PNG または JPEG 形式の画像のみ対応しています。');
      imgInput.value = '';
      return;
    }

    if(currentBlobURL){
      URL.revokeObjectURL(currentBlobURL);
    }
    currentBlobURL = URL.createObjectURL(file);
    bg.src = currentBlobURL;
  });

  opacityInput.addEventListener('input', ()=>{
    state.opacity = parseFloat(opacityInput.value);
    draw();
  });

  ppmInput.addEventListener('change', ()=>{
    const v = parseFloat(ppmInput.value);
    state.ppm = isFinite(v) && v>0 ? v : state.ppm;
    ppmInput.value = state.ppm;
    draw();
  });

  resetBtn.addEventListener('click', ()=>{
    if(currentBlobURL){
      URL.revokeObjectURL(currentBlobURL);
      currentBlobURL = null;
    }
    bg.src = '';
    imgInput.value = '';

    state.origin = {x:150, y:600};
    state.ppm = 100; ppmInput.value = 100;
    state.opacity = 0.85; opacityInput.value = 0.85;
    state.calibMode = false; state.calibPts = [];
    state.slants = [
      { id:"road",   label:"道路斜線", type:"road",   enabled:true,  mode:"slope", h0:1.2, m:1.25, theta:degFromSlope(1.25), d0:0, phi:0,   flip:false, color:"#2563eb" },
      { id:"north",  label:"北側斜線", type:"north",  enabled:true,  mode:"slope", h0:5.0, m:1.25, theta:degFromSlope(1.25), d0:0, phi:0,   flip:false, color:"#16a34a" },
      { id:"custom", label:"高度/カスタム斜線", type:"custom", enabled:false, mode:"angle", h0:0, m:slopeFromDeg(40), theta:40, d0:0, phi:0, flip:false, color:"#dc2626" },
    ];
    renderPanels();
    draw();
  });

  // ----- 原点ドラッグ & 縮尺キャリブレーション -----
  let dragging = false;
  stage.addEventListener('mousedown', (e)=>{
    const rect = stage.getBoundingClientRect();
    const ox = state.origin.x, oy = state.origin.y;
    const mx = e.clientX - rect.left, my = e.clientY - rect.top;

    if(state.calibMode){
      state.calibPts.push({x:mx,y:my});
      draw();
      if(state.calibPts.length===2){
        const dx = state.calibPts[1].x - state.calibPts[0].x;
        const dy = state.calibPts[1].y - state.calibPts[0].y;
        const pix = Math.hypot(dx,dy);
        const val = prompt("この2点の実距離[m]を入力してください：", "10");
        const m = parseFloat(val||"");
        if(isFinite(m) && m>0){
          state.ppm = pix / m;
          ppmInput.value = Math.round(state.ppm);
        }
        state.calibMode = false; state.calibPts = [];
        calibBtn.textContent = "縮尺キャリブレーション";
        draw();
      }
      return;
    }

    if(Math.hypot(mx-ox,my-oy) <= 12){
      dragging = true;
      e.preventDefault();
    }
  });
  window.addEventListener('mousemove', (e)=>{
    if(!dragging) return;
    const rect = stage.getBoundingClientRect();
    state.origin.x = clamp(e.clientX - rect.left, 0, state.canvas.w);
    state.origin.y = clamp(e.clientY - rect.top, 0, state.canvas.h);
    draw();
  });
  window.addEventListener('mouseup', ()=> dragging=false);

  calibBtn.addEventListener('click', ()=>{
    state.calibMode = !state.calibMode;
    state.calibPts = [];
    calibBtn.textContent = state.calibMode ? "キャリブ中…（ステージ上を2点クリック）" : "縮尺キャリブレーション";
  });

  // ----- PNG保存 -----
  function downloadURI(uri, name){
    const a = document.createElement('a');
    a.download = name; a.href = uri; document.body.appendChild(a);
    a.click(); a.remove();
  }

  saveBtn.addEventListener('click', async ()=>{
    try{
      const canvas = document.createElement('canvas');
      canvas.width = state.canvas.w; canvas.height = state.canvas.h;
      const ctx = canvas.getContext('2d');

      if(bg.src){
        await new Promise((res, rej)=>{
          const img = new Image();
          img.onload = ()=>{ 
            const cw = canvas.width, ch = canvas.height;
            const iw = img.width, ih = img.height;
            const s = Math.min(cw/iw, ch/ih);
            const dw = iw*s, dh = ih*s;
            const dx = (cw - dw)/2, dy = (ch - dh)/2;
            ctx.globalAlpha = state.opacity;
            ctx.drawImage(img, dx, dy, dw, dh);
            ctx.globalAlpha = 1;
            res();
          };
          img.onerror = ()=>{ rej(new Error('背景画像の読み込みに失敗しました。')); };
          img.src = bg.src;
        });
      }

      const data = new XMLSerializer().serializeToString(overlay);
      const svgBlob = new Blob([data], {type:"image/svg+xml;charset=utf-8"});
      const url = URL.createObjectURL(svgBlob);
      await new Promise((res, rej)=>{
        const img = new Image();
        img.onload = ()=>{ ctx.drawImage(img,0,0); URL.revokeObjectURL(url); res(); };
        img.onerror = ()=>{ URL.revokeObjectURL(url); rej(new Error('SVGオーバーレイの描画に失敗しました。')); };
        img.src = url;
      });

      downloadURI(canvas.toDataURL("image/png"), "slant_overlay.png");
    }catch(err){
      console.error('PNG書き出しエラー:', err);
      alert(`PNG書き出しでエラーが発生しました。\n\nエラー詳細: ${err.message || err}`);
    }
  });

  // ----- 初期化 -----
  function init(){
    overlay.setAttribute("viewBox", `0 0 ${state.canvas.w} ${state.canvas.h}`);
    originEl.style.left = state.origin.x + "px";
    originEl.style.top = state.origin.y + "px";
    originLabel.style.left = state.origin.x + "px";
    originLabel.style.top = state.origin.y + "px";
    renderPanels();
    draw();
  }
  init();
})();
</script>


</body>
</html>
